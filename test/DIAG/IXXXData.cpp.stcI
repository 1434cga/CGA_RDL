stcI_HASH : Module_Name
stcI_FILEPREFIX : KEYManagerService/lib/I
stcI_FILEPOSTFIX : Data
stcI_EXTENSION : cpp
Set : $iterate_comments = OFF
SetI : $MODULENAME = KEY
/*
 *   This software is copyright protected and proprietary to
 *   LG electronics. LGE grants to you only those rights as
 *   set out in the license conditions. All other rights remain
 *   with LG electronics.
 * \author  Jong Kyung Byun
 * \date    2017.11.14
 * \attention Copyright (c) 2015 by LG electronics co, Ltd. All rights reserved.
 */


#define LOG_TAG "I+<+$MODULENAME+>+Data"
#include "Log.h"

#include "../include/+<+$MODULENAME+>+Command.h"

#include <stdio.h>

#define SLDDprintMessage(...) (fprintf(stdout, __VA_ARGS__))

+<+$MODULENAME+>+Data::+<+$MODULENAME+>+Data(const +<+$MODULENAME+>+Data& other)
{
    setTo(other);
}

+<+$MODULENAME+>+Data::~+<+$MODULENAME+>+Data(void)
{
ITERATE %xxData +<<+ ITKEY  ITVALUE
    IFEQUAL(+<+$xxData{ITKEY}{Len}+>+  ne "")+{{+
        if( this->+<+$xxData{ITKEY}{name}+>+ != NULL){      // size: +<+$xxData{ITKEY}{Len}+>+ 
            delete [] this->+<+$xxData{ITKEY}{name}+>+ ;
            this->+<+$xxData{ITKEY}{name}+>+ = NULL;
        }
    +}}+
+>>+

/*
    if (this->data != NULL) {
        delete [] this->data;
        this->data = NULL;
    }
*/
}

+<+$MODULENAME+>+Data& +<+$MODULENAME+>+Data::operator=(const +<+$MODULENAME+>+Data& other)
{
    setTo(other);
    return *this;
}

void +<+$MODULENAME+>+Data::setData(
ITERATE %xxData +<<+ ITKEY  ITVALUE
    IFEQUAL(ITKEY eq 1)+{{+
        IFNOTEQUAL(+<+$xxData{ITKEY}{Len}+>+  ne "")+{{+
            +<+$xxData{ITKEY}{type}+>+ m+<+$xxData{ITKEY}{name}+>+  
        +}}+
        IFEQUAL(+<+$xxData{ITKEY}{Len}+>+  ne "")+{{+
            size_t m+<+$xxData{ITKEY}{Len}+>+  
            , +<+$xxData{ITKEY}{type}+>+ m+<+$xxData{ITKEY}{name}+>+  
        +}}+
    +}}+
    IFEQUAL(ITKEY ne 1)+{{+
        IFNOTEQUAL(+<+$xxData{ITKEY}{Len}+>+  ne "")+{{+
            , +<+$xxData{ITKEY}{type}+>+ m+<+$xxData{ITKEY}{name}+>+  
        +}}+
        IFEQUAL(+<+$xxData{ITKEY}{Len}+>+  ne "")+{{+
            , size_t m+<+$xxData{ITKEY}{Len}+>+  
            , +<+$xxData{ITKEY}{type}+>+ m+<+$xxData{ITKEY}{name}+>+  
        +}}+
    +}}+
+>>+
    //  uint16_t mDid, uint16_t mLen, uint8_t mAtt, uint8_t* mData
    )
{


ITERATE %xxData +<<+ ITKEY  ITVALUE
    IFNOTEQUAL(+<+$xxData{ITKEY}{Len}+>+  ne "")+{{+
        this->+<+$xxData{ITKEY}{name}+>+ = m+<+$xxData{ITKEY}{name}+>+ ;
    +}}+
    IFEQUAL(+<+$xxData{ITKEY}{Len}+>+  ne "")+{{+
        if( this->+<+$xxData{ITKEY}{Len}+>+ != 0){
            this->+<+$xxData{ITKEY}{name}+>+  = new  unit8_t[ m+<+$xxData{ITKEY}{Len}+>+ ];
            memcpy(this->+<+$xxData{ITKEY}{name}+>+ , m+<+$xxData{ITKEY}{name}+>+ , m+<+$xxData{ITKEY}{Len}+>+ );
        } else {
            int _mSize = 2;
            uint8_t payload[_mSize] = {0,};
            this->+<+$xxData{ITKEY}{name}+>+  = new  unit8_t[ _mSize ];
            memcpy(this->+<+$xxData{ITKEY}{name}+>+ , payload , _mSize );
            LOGV("+<+$MODULENAME+>+ this->+<+$xxData{ITKEY}{name}+>+ setData mthis->+<+$xxData{ITKEY}{Len}+>+ is 0");
        }
    +}}+
+>>+

/*
    this->did = mDid;
    this->len = mLen;
    this->att = mAtt;
    if (mLen != 0) {
            this->data =  new uint8_t [mLen];
            memcpy (this->data, mData, mLen);
    }
    else {
            int mSize = 2;
            uint8_t payload[mSize] = {0,};

            this->data =  new uint8_t [mSize];

            memcpy (this->data, payload, mSize);
            LOGV("+<+$MODULENAME+>+Data setData mLen is 0");
    }
*/

}

void +<+$MODULENAME+>+Data::setTo(const +<+$MODULENAME+>+Data& other)
{
ITERATE %xxData +<<+ ITKEY  ITVALUE
    this->+<+$xxData{ITKEY}{name}+>+ = other.+<+$xxData{ITKEY}{name}+>+ ; 
+>>+

/*
    this->did = other.did;
    this->len = other.len;
    this->att = other.att;
    this->data = other.data;
*/
}

error_t +<+$MODULENAME+>+Data::writeToParcel(android::Parcel* parcel)
{
ITERATE %xxData +<<+ ITKEY  ITVALUE
    IFNOTEQUAL(+<+$xxData{ITKEY}{Len}+>+  ne "")+{{+
        (void)parcel->+<+$ArgType1{$xxData{ITKEY}{type}}{write}+>+ ( this->+<+$xxData{ITKEY}{name}+>+ );
    +}}+
    IFEQUAL(+<+$xxData{ITKEY}{Len}+>+  ne "")+{{+
        (void)parcel->+<+$ArgType1{$xxData{ITKEY}{type}}{write}+>+ ( this->+<+$xxData{ITKEY}{Len}+>+ , this->+<+$xxData{ITKEY}{name}+>+ );
    +}}+
+>>+

/*
    (void)parcel->writeInt32(this->did);
    (void)parcel->writeInt32(this->len);
    (void)parcel->writeInt32(this->att);
    (void)parcel->writeByteArray(this->len,this->data);
*/

    return E_OK;
}

error_t +<+$MODULENAME+>+Data::readFromParcel(const android::Parcel& parcel)
{
ITERATE %xxData +<<+ ITKEY  ITVALUE
    IFNOTEQUAL(+<+$xxData{ITKEY}{Len}+>+  ne "")+{{+
        this->+<+$xxData{ITKEY}{name}+>+  = (void)parcel.+<+$ArgType1{$xxData{ITKEY}{type}}{read}+>+ (); // ? need static_cast
    +}}+
    IFEQUAL(+<+$xxData{ITKEY}{Len}+>+  ne "")+{{+
        this->+<+$xxData{ITKEY}{Len}+>+  = parcel.readInt32();
        if( (this->+<+$xxData{ITKEY}{Len}+>+  < 0) || ( this->+<+$xxData{ITKEY}{name}+>+  == NULL) )
            return E_OK;
        parcel.read( this->+<+$xxData{ITKEY}{name}+>+ , this->+<+$xxData{ITKEY}{Len}+>+ );
    +}}+
+>>+

/*
    this->did = parcel.readInt32();
    uint32_t tempSize  = parcel.readInt32();
    this->len = tempSize;
    this->att = parcel.readInt32();


         this->did = parcel.readInt32();
         138     this->kkk = parcel.readInt32();
         139     this->att = parcel.readInt32();
         140
         141
         142     this->dataLen = parcel.readInt32();
         143     if ( (this->dataLen<0) || (this->data == NULL))
         144         return E_OK;
         145     parcel.read(this->data, this->dataLen);


    size_t arrayLength = static_cast<uint32_t>(parcel.readInt32());

    if (arrayLength<0)
        return E_OK;

    const uint8_t* bytes = reinterpret_cast<const uint8_t*>(parcel.readInplace(tempSize));

    uint8_t * copyBytes = new uint8_t[tempSize];

    if (bytes != NULL)
        memcpy (copyBytes,bytes,tempSize);
    else
        LOGV("+<+$MODULENAME+>+Data readFromParcel Bytes is null");
    parcel.read(copyBytes,tempSize);
    setData(this->did, this->len, this->att, copyBytes);
    delete [] copyBytes;
*/

    return E_OK;
}

ITERATE %xxData +<<+ ITKEY  ITVALUE
    IFEQUAL(+<+$xxData{ITKEY}{Len}+>+  ne "")+{{+
        size_t  get+<+ucfirst($xxData{ITKEY}{Len})+>+()
        {
            return this->+<+$xxData{ITKEY}{Len}+>+;
        }
    +}}+
+<+$xxData{ITKEY}{type}+>+  get+<+ucfirst($xxData{ITKEY}{name})+>+()
{
    return this->+<+$xxData{ITKEY}{name}+>+;
}
+>>+

/*
uint16_t +<+$MODULENAME+>+Data::getDid()
{
    return this->did;
}

uint16_t +<+$MODULENAME+>+Data::getLen()
{
    return this->len;
}

uint8_t +<+$MODULENAME+>+Data::getAtt()
{
    return this->att;
}

uint8_t * +<+$MODULENAME+>+Data::getData()
{
    return this->data;
}
*/

void +<+$MODULENAME+>+Data::toString()
{
    LOGV("============================================================");
    LOGV("+<+$MODULENAME+>+Data did         = %x", this->did);
    LOGV("+<+$MODULENAME+>+Data len         = %d", this->len);
    LOGV("+<+$MODULENAME+>+Data att         = %d", this->att);

    if(this->data !=NULL)
        {
            if ((this->len) > 0) {

                    for (int32_t i = 0; i<this->len;i++)
                    LOGV("+<+$MODULENAME+>+Data data [%d] : 0x%02x",i,this->data[i]);

                }
         }
    LOGV("============================================================");
}

void +<+$MODULENAME+>+Data::toString(char* from)
{
    LOGV("============================================================");
    LOGV("%s() +<+$MODULENAME+>+Data did         = %x", from, this->did);
    LOGV("%s() +<+$MODULENAME+>+Data len         = %d", from, this->len);
    LOGV("%s() +<+$MODULENAME+>+Data att         = %d", from, this->att);
    if(this->data !=NULL)
        {
            if ((this->len) > 0) {

                    for (int32_t i = 0; i<this->len;i++)
                    LOGV("+<+$MODULENAME+>+Data data [%d] : 0x%02x",i,this->data[i]);

                }
         }

    LOGV("============================================================");
}

