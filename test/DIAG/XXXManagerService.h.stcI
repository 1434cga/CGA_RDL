stcI_HASH : Module_Name
stcI_FILEPREFIX : KEYManagerService/src/
stcI_FILEPOSTFIX : ManagerService
stcI_EXTENSION : h
Set : $iterate_comments = OFF
SetI : $MODULENAME = KEY
/*
 *   This software is copyright protected and proprietary to
 *   LG electronics. LGE grants to you only those rights as
 *   set out in the license conditions. All other rights remain
 *   with LG electronics.
 * \author  Jong Kyung Byun
 * \date    2017.11.14
 * \attention Copyright (c) 2015 by LG electronics co, Ltd. All rights reserved.
 */

#ifndef _SERVICELAYER_+<+uc($MODULENAME)+>+NOSTIC_MANAGER_SERVICE_H_
#define _SERVICELAYER_+<+uc($MODULENAME)+>+NOSTIC_MANAGER_SERVICE_H_

#include <map>
#include <list>

#include <Typedef.h>
#include <corebase/SystemService.h>

#include "+<+ucfirst($MODULENAME)+>+InputManager.h"

#include <services/+<+ucfirst($MODULENAME)+>+ManagerService/+<+ucfirst($MODULENAME)+>+Command.h>
#include <services/+<+ucfirst($MODULENAME)+>+ManagerService/I+<+ucfirst($MODULENAME)+>+ManagerReceiver.h>
#include <services/+<+ucfirst($MODULENAME)+>+ManagerService/I+<+ucfirst($MODULENAME)+>+ManagerService.h>

class +<+ucfirst($MODULENAME)+>+ManagerService: public SystemService
{
public:
	+<+ucfirst($MODULENAME)+>+ManagerService();
	virtual ~+<+ucfirst($MODULENAME)+>+ManagerService();

	static const char* getServiceName() { return "service_layer.+<+ucfirst($MODULENAME)+>+ManagerService"; }
	virtual uint8_t getModuleID() { return MODULE_+<+uc($MODULENAME)+>+; }

	virtual bool onInit();
	virtual void instantiate();
	virtual error_t onStart();
	virtual error_t onStop();
	virtual error_t dump(LogOutput&);

	error_t attachReceiver(serviceid_t id, android::sp<I+<+ucfirst($MODULENAME)+>+ManagerReceiver>& receiver);
	error_t unregisterReceiver(const android::sp<I+<+ucfirst($MODULENAME)+>+ManagerReceiver>& receiver);

	error_t queryReceiverById(appid_t id, android::sp<+<+ucfirst($MODULENAME)+>+Data>& m+<+ucfirst($MODULENAME)+>+Data);
	bool isApplicationExecuted(appid_t id);
	error_t requestResponseDataID(android::sp<+<+ucfirst($MODULENAME)+>+Data>& m+<+ucfirst($MODULENAME)+>+Data);

	void onReceiverBinderDied(const android::wp<android::IBinder>& who);

#ifdef +<+uc($MODULENAME)+>+_SLDD_TEST
	error_t SlddTestCmd(uint8_t id, uint8_t cmd, uint8_t cmd2, android::sp<Buffer> buf);
	android::sp<Buffer> SLDDRequestDataID(uint16_t index);
	error_t SLDDResponseDataID (uint16_t request_id, android::sp<Buffer> buf);
#endif

private:
	class ReceiverDeathRecipient : public android::IBinder::DeathRecipient {
	public:
		ReceiverDeathRecipient(+<+ucfirst($MODULENAME)+>+ManagerService& parent) : mParent(parent) {}
		virtual ~ReceiverDeathRecipient() {}
		virtual void binderDied(const android::wp<android::IBinder>& who)
			{ mParent.onReceiverBinderDied(who); }
	private:
		+<+ucfirst($MODULENAME)+>+ManagerService& mParent;
	};

private:
	class ServiceStub: public Bn+<+ucfirst($MODULENAME)+>+ManagerService {
	public:
		ServiceStub(+<+ucfirst($MODULENAME)+>+ManagerService& parent) : mParent(parent) {}
		error_t queryReceiverById(appid_t id, android::sp<+<+ucfirst($MODULENAME)+>+Data>& m+<+ucfirst($MODULENAME)+>+Data);
		virtual error_t attachReceiver(serviceid_t id, android::sp<I+<+ucfirst($MODULENAME)+>+ManagerReceiver>& receiver);
		virtual error_t unregisterReceiver(const android::sp<I+<+ucfirst($MODULENAME)+>+ManagerReceiver>& receiver);
		virtual error_t requestDataID(android::sp<+<+ucfirst($MODULENAME)+>+Data>& m+<+ucfirst($MODULENAME)+>+Data);
		virtual error_t responseDataID(android::sp<+<+ucfirst($MODULENAME)+>+Data>& m+<+ucfirst($MODULENAME)+>+Data);

	// auto CGA start
ITERATE %API +<<+ ITKEY  ITVALUE
	virtual error_t ITKEY(android::sp<+<+ucfirst($MODULENAME)+>+Data>& m+<+ucfirst($MODULENAME)+>+Data);
+>>+
	// auto CGA end

#ifdef +<+uc($MODULENAME)+>+_SLDD_TEST
		virtual error_t SlddTestCmd(uint8_t, uint8_t, uint8_t, android::sp<Buffer>);
		virtual sp<Buffer> SLDDRequestDataID(uint16_t index);
		virtual error_t SLDDResponseDataID (uint16_t request_id, android::sp<Buffer> buf);
#endif

	private:
		+<+ucfirst($MODULENAME)+>+ManagerService& mParent;
	};

private:
	android::sp<+<+ucfirst($MODULENAME)+>+InputManager> m+<+ucfirst($MODULENAME)+>+InputMgr;
	std::map<int32_t, std::list< android::sp<I+<+ucfirst($MODULENAME)+>+ManagerReceiver>> > mReceivers;

	int32_t mCurrentPowerState;
	mutable Mutex mReceiverLock;

	android::sp<ReceiverDeathRecipient> mReceiverDeathRecipient;
};

#endif // _SERVICELAYER_+<+uc($MODULENAME)+>+NOSTIC_MANAGER_SERVICE_H_
